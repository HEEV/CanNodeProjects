/**
 * \file main.c
 * \brief main file for the CanNode project for Cedarville Supermileage.
 * Automatically generated by STCubeMX then hacked beyond recognition by
 * Samuel Ellicott
 *
 * \author Samuel Ellicott
 * \date 6-8-16
 */

#include <CanNode.h>
#include <limits.h>
#include <stdint.h>
#include <stdlib.h>
#include <stm32f0xx_hal.h>
#include <stm32f0xx_hal_conf.h>
#include <string.h>

//#define USBDEBUG

#ifdef USBDEBUG
#include "usb_device.h"
#include "usbd_cdc_if.h"
#endif

#define IO1_ADC ADC_CHANNEL_8
#define IO2_ADC ADC_CHANNEL_7

 /* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
void MX_GPIO_Init(void);
void MX_ADC_Init(void);
void MX_TIM3_Init(void);

/* Private function prototypes -----------------------------------------------*/
void throttleRTR(CanMessage *data);
void newThrottlePos(CanMessage *data);

uint16_t throttleAdjust(uint16_t adcVal);
uint16_t throttleToServo(uint16_t throttlePos);
void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim);

/// Struct for initilizing ADC
ADC_HandleTypeDef hadc;
CAN_HandleTypeDef hcan;
TIM_HandleTypeDef htim3;
/// Struct for recieving throttle values

CanNode *throttle;

/// global flag (set in \ref Src/usb_cdc_if.c) for whether USB is connected
volatile uint8_t USBConnected;
uint16_t pitotVoltage;
//boolean flag, set if a can message for the throttle is recieved, will disable
//ADC based throttle
volatile bool canThrottleMessage;

int main(void) {

	USBConnected = false;
    canThrottleMessage = false;
    uint16_t aveAdc = 0;
    uint16_t adcVals[10] = {0};
    uint8_t valIndex = 0;
    uint16_t newServoPos;

	// Reset of all peripherals, Initializes the Flash interface and the Systick.
	HAL_Init();
	// Configure the system clock
	SystemClock_Config();
	// Initialize all configured peripherals
	MX_GPIO_Init();
	MX_ADC_Init();
	MX_TIM3_Init();

#ifdef USBDEBUG 
	MX_USB_DEVICE_Init();
#endif

	//HAL_Delay(50);

	// setup CAN, ID's, and gives each an RTR callback

    //throttle = CanNode_init(THROT_BODY, throttleRTR);

	//initialize the can object
	CanNode throttleNode(THROTTLE, throttleRTR);
	throttle = &throttleNode;

	
	// get new throttle position information from the THROTTLE device
	//bool FILTER_ADDED; use if filter added flag is wanted
    throttle->addFilter(THROTTLE,throttleRTR);
	while (1) {
		// check if there is a message necessary for CanNode functionality
        CanNode::checkForMessages();


        //if there has not been a CAN Message use the ADC based throttle messages
        if(canThrottleMessage == false) {
            // read the ADC on IO1
            HAL_ADC_Start(&hadc);
            HAL_ADC_PollForConversion(&hadc, 5);

            adcVals[valIndex] = HAL_ADC_GetValue(&hadc);
            valIndex++;
            if(valIndex >= 10){
                valIndex = 0;
            }
            
            //average values
            uint32_t temp = 0;
            for(int i = 0; i<10; i++){
                temp += adcVals[i];
            }

            aveAdc  = temp / 10;

            newServoPos = throttleToServo(throttleAdjust(aveAdc));
            __HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_2, newServoPos);
        }

		// get the current time
		uint32_t time = HAL_GetTick();

#ifdef USBDEBUG
		if (time % 500 == 0) {
			char buff1[5];
            char buff[32];
            
			HAL_GPIO_TogglePin(GPIOB, LED1_Pin);

			
            itoa(aveAdc, buff1, 10);
            strcpy(buff, buff1);
            strcat(buff, ", ");

            itoa(throttleAdjust(aveAdc), buff1, 10);
            strcat(buff, buff1);
            strcat(buff, ", ");

            itoa(throttleToServo(throttleAdjust(aveAdc)), buff1, 10);
            strcat(buff, buff1);
            strcat(buff, "\n");

            //itoa(newServoPos, buff, 10);
            // send a break between data sets
            //strcat(buff, "\n");

            CDC_Transmit_FS((uint8_t *)buff, strlen(buff));
		}
#endif

		// every 30 seconds reset the CAN hardware I don't know why this is
		// necessary
		HAL_Delay(1);
	}
}

/// RTR handler for the throttle id
void throttleRTR(CanMessage *data) {
	// send the current throttle value
	uint32_t pos = __HAL_TIM_GET_COMPARE(&htim3, TIM_CHANNEL_2);
	throttle->sendData_uint32(pos);

}

void newThrottlePos(CanMessage *data) {
	uint16_t throttlePos;
	throttle->getData_uint16(data, &throttlePos);

	uint16_t newServoPos = throttleToServo(throttleAdjust(throttlePos));

	__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_2, newServoPos);

	// toggle red led on message
	HAL_GPIO_TogglePin(GPIOB, LED2_Pin);
    canThrottleMessage = true;
}

//Returns an output between 0 and 4096
//Splits the throttle into two linear regions
//whose slopes are adjusted by transX, and transY
//variables.
uint16_t throttleAdjust(uint16_t adcVal){
    const uint16_t MAX_VAL = 4096;
    const uint16_t transX = 1400;
    const uint16_t transY = 1000;

    //first slope
    if(adcVal < transX) {
        uint32_t temp = adcVal * transY;
        return (uint16_t) (temp/transX);
    }

    //second slope
    uint32_t temp = (adcVal - transX) * (MAX_VAL - transY);
    temp = (temp/(MAX_VAL - transX));
    return (uint16_t) temp + transY;
}
uint16_t throttleToServo(uint16_t throttlePos) {
	uint32_t servoTime;

	const uint16_t servoMax = 1155;
	//const uint16_t servoMin = 1950;
	const uint16_t servoMin = 1990;
	//const uint16_t throttleMax = 3360;
	const uint16_t throttleMax = 2100;
	//const uint16_t throttleMin = 634;
	const uint16_t throttleMin = 458;

	// change the maximum value of throttlePos to the maximum servo time
	servoTime = ((servoMax - servoMin) * (throttlePos - throttleMin)) /
		(throttleMax - throttleMin) +
		servoMin;

    if(servoTime < servoMax) servoTime = servoMax;
    else if(servoTime > servoMin) servoTime = servoMin;
	return (uint16_t)servoTime;
}

void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
{

  GPIO_InitTypeDef GPIO_InitStruct;
  if(htim->Instance==TIM3)
  {
  /* USER CODE BEGIN TIM3_MspPostInit 0 */

  /* USER CODE END TIM3_MspPostInit 0 */

    /**TIM3 GPIO Configuration
    PA7     ------> TIM3_CH2
    */
    GPIO_InitStruct.Pin = IO2_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM3;
    HAL_GPIO_Init(IO2_GPIO_Port, &GPIO_InitStruct);

  /* USER CODE BEGIN TIM3_MspPostInit 1 */

    HAL_TIM_PWM_Start(htim,TIM_CHANNEL_2);

  /* USER CODE END TIM3_MspPostInit 1 */
  }

}

/** System Clock Configuration
*/
void SystemClock_Config(void) {

	RCC_OscInitTypeDef RCC_OscInitStruct;
	RCC_ClkInitTypeDef RCC_ClkInitStruct;
	RCC_PeriphCLKInitTypeDef PeriphClkInit;

	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI14 |
		RCC_OSCILLATORTYPE_HSI48 |
		RCC_OSCILLATORTYPE_LSI;

	RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
	RCC_OscInitStruct.HSI14State = RCC_HSI14_ON;
	RCC_OscInitStruct.HSI14CalibrationValue = 16;
	RCC_OscInitStruct.LSIState = RCC_LSI_ON;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI48;
	RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL2;
	RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV6;
	HAL_RCC_OscConfig(&RCC_OscInitStruct);

	RCC_ClkInitStruct.ClockType =
		RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1;

	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
	HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0);

	PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB | RCC_PERIPHCLK_RTC;
	PeriphClkInit.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
	PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_HSI48;
	HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit);

	HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq() / 1000);

	HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);

	/* SysTick_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
}

/* ADC init function */
void MX_ADC_Init(void) {
	ADC_ChannelConfTypeDef sConfig;

	/**Configure the global features of the ADC (Clock, Resolution, Data Alignment
	 * and number of conversion)
	*/
	hadc.Instance = ADC1;
	hadc.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
	hadc.Init.Resolution = ADC_RESOLUTION_12B;
	hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
	hadc.Init.ScanConvMode = ADC_SCAN_DIRECTION_FORWARD;
	hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
	hadc.Init.LowPowerAutoWait = DISABLE;
	hadc.Init.LowPowerAutoPowerOff = DISABLE;
	hadc.Init.ContinuousConvMode = DISABLE;
	hadc.Init.DiscontinuousConvMode = ENABLE;
	hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
	hadc.Init.DMAContinuousRequests = DISABLE;
	hadc.Init.Overrun = ADC_OVR_DATA_PRESERVED;
	HAL_ADC_Init(&hadc);

	/**Configure for the selected ADC regular channel to be converted.
	*/
	sConfig.Channel = IO1_ADC;
	sConfig.Rank = ADC_RANK_CHANNEL_NUMBER;
	sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
	HAL_ADC_ConfigChannel(&hadc, &sConfig);
}

/* TIM3 init function */
void MX_TIM3_Init(void) {

	TIM_ClockConfigTypeDef sClockSourceConfig;
	TIM_MasterConfigTypeDef sMasterConfig;
	TIM_OC_InitTypeDef sConfigOC;

	htim3.Instance = TIM3;
	htim3.Init.Prescaler = 16; // divide system clock (16Mhz) by 16
	htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim3.Init.Period =
		20000; // set frequency to 50hz (divide prescalaed clock by 20000)
	htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	HAL_TIM_Base_Init(&htim3);

	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
	HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig);

	HAL_TIM_PWM_Init(&htim3);

	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig);

	sConfigOC.OCMode = TIM_OCMODE_PWM1;
	sConfigOC.Pulse = 0;
	sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
	sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
	HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2);

	HAL_TIM_MspPostInit(&htim3);
}

/** Configure pins as
 * Analog
 * Input
 * Output
.* EVENT_OUT
.* EXTI
.* Free pins are configured automatically as Analog (this feature is enabled
through
.* the Code Generation settings)
*/
void MX_GPIO_Init(void) {

	GPIO_InitTypeDef GPIO_InitStruct;

	// Make all unused pins analog to save power
	/* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOC_CLK_ENABLE();
	__HAL_RCC_GPIOF_CLK_ENABLE();

	/*Configure GPIO pins : PC13 PC14 PC15 */
	GPIO_InitStruct.Pin = GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_15;
	GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	/*Configure GPIO pins : PF0 PF1 PF11 */
	GPIO_InitStruct.Pin = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_11;
	GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);

	/*Configure GPIO pins : PA0 PA1 PA2 PA3
					   PA4 PA5 PA6 PA8
					   PA9 PA10 PA15 */
	GPIO_InitStruct.Pin = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3 |
		GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_6 | GPIO_PIN_8 |
		GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_15;
	GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

	/*Configure GPIO pins : PB1 PB2 PB10 PB11
					   PB12 PB13 PB14 PB15
					   PB5 PB6 PB7 */
	GPIO_InitStruct.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_10 | GPIO_PIN_11 |
		GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_15 |
		GPIO_PIN_5 | GPIO_PIN_6 | GPIO_PIN_7;
	GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

	__HAL_RCC_GPIOC_CLK_DISABLE();
	__HAL_RCC_GPIOF_CLK_DISABLE();

	// Enable used io pins
	__HAL_RCC_GPIOA_CLK_ENABLE();
	__HAL_RCC_GPIOB_CLK_ENABLE();

	/*Configure GPIO pins : LED2_Pin LED1_Pin */
	GPIO_InitStruct.Pin = LED2_Pin | LED1_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOB, LED2_Pin | LED1_Pin, GPIO_PIN_SET);

	// configure IO1 as a rising edge interrupt pin
	// GPIO_InitStruct.Pin = IO2_Pin;
	// GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
	// GPIO_InitStruct.Pull = GPIO_PULLDOWN;
	// HAL_GPIO_Init(IO2_GPIO_Port, &GPIO_InitStruct);

	/* EXTI4_15_IRQn interrupt configuration */
	// HAL_NVIC_SetPriority(EXTI4_15_IRQn, 0, 0);
	// HAL_NVIC_EnableIRQ(EXTI4_15_IRQn);
}

/**
  * @brief  This function is executed in case of error occurrence.
  * @param  None
  * @retval None
  */
void _Error_Handler(char * file, int line)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  while(1) 
  {
  }
  /* USER CODE END Error_Handler_Debug */ 
}

#ifdef USE_FULL_ASSERT

/**
   * @brief Reports the name of the source file and the source line number
   * where the assert_param error has occurred.
   * @param file: pointer to the source file name
   * @param line: assert_param error line source number
   * @retval None
   */
void assert_failed(uint8_t* file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
    ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */

}
#endif
